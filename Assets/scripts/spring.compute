// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define SPRING_COUNT 8

struct Point
{
    float2 position;
    float2 velocity;
};

struct SpringInfos
{
    int firstIndex;
    int secondIndex;
    float initialDistance;
};

struct PersistentPointInfo
{
    float2 initialPosition;
    int springIndecies[SPRING_COUNT];
};

struct Result
{
    float2 velocity;
};

StructuredBuffer<Point> points;
StructuredBuffer<PersistentPointInfo> persistentPointInfo;
StructuredBuffer<SpringInfos> springInfos;
RWStructuredBuffer<Result> results;
float4 _mousePosition;
float4 _mouseVector;
float mousePushForce;
float mouseCutoff;
uint pointCount;
float springConstant;
float damping;
float returnForce;
float maxReturnDistance;
float minimumGate;
float deltaTime;

// Create a RenderTexture with enableRandomWrite flag and set it.
// with cs.SetTexture
// RWTexture2D<float4> Result;

[numthreads(256, 1, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    float2 mousePosition = _mousePosition.xy;
    float2 mouseVector = _mouseVector.xy;
    uint idx = id.x;
    if (idx >= pointCount)
        return;
    int firstIndex = idx;
    float2 first = points[firstIndex].position;
    float2 firstOrigin = persistentPointInfo[firstIndex].initialPosition;
    float2 velocity = points[firstIndex].velocity;
    Result initRes;
    initRes.velocity = 0;
    results[firstIndex] = initRes;
    for (int i = 0; i < SPRING_COUNT; i++)
    {
        int springIndex = persistentPointInfo[firstIndex].springIndecies[i];
        if (springIndex == -1)
            break;
        int secondIndex = 0;
        if (firstIndex == springInfos[springIndex].firstIndex)
            secondIndex = springInfos[springIndex].secondIndex;
        else
            secondIndex = springInfos[springIndex].firstIndex;
        float2 second = points[secondIndex].position;
        float2 secondVelocity = points[secondIndex].velocity;
        float minDistance = springInfos[springIndex].initialDistance;
        float dist = distance(first, second);

        float2 secondFinalVelocity;
        float2 finalVelocity;

        if (dist < minDistance) // abs(dist - minDistance) < 0.1)
        {
            finalVelocity = float2(0, 0);
            secondFinalVelocity = float2(0, 0);
        }
        else
        {
            float force = (dist - minDistance) * springConstant;
            // if (dist < minDistance) force = -force;
            float2 direction = normalize(second - first);
            finalVelocity = direction * force - velocity * damping;
        }
        float firstOriginDistance = distance(first, firstOrigin);
        if (firstOriginDistance < maxReturnDistance && firstOriginDistance > 0.005)
        {
            float2 direction = normalize(firstOrigin - first);
            finalVelocity += direction * returnForce * max(firstOriginDistance, 0.1);
        }

        if (length(finalVelocity) < minimumGate)
            finalVelocity = finalVelocity * (0.3 - 0.3 * (minimumGate - length(finalVelocity)) / minimumGate) - velocity * 0.5;

        float mouseDist = distance(mousePosition, first);
        if (mouseDist < mouseCutoff && mouseDist > 0.01)
        {
            float2 direction = normalize(normalize(first - mousePosition) + mouseVector);
            finalVelocity += mousePushForce / mouseDist * direction;
        }

        results[firstIndex].velocity += finalVelocity * deltaTime;
    }
}