// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define SPRING_COUNT 8

struct Point
{
    float2 position;
    float2 velocity;
};

struct SpringInfos
{
    int firstIndex;
    int secondIndex;
    float initialDistance;
};

struct PersistentPointInfo
{
    float2 initialPosition;
    int springIndecies[SPRING_COUNT];
};

struct Result
{
    float2 firstVelocity;
};

StructuredBuffer<Point> points;
StructuredBuffer<PersistentPointInfo> persistentPointInfo;
StructuredBuffer<SpringInfos> springInfos;
RWStructuredBuffer<Result> results;
uint pairCount;
float springConstant;
float damping;
float returnForce;
float maxReturnDistance;
float minimumGate;
float deltaTime;

// Create a RenderTexture with enableRandomWrite flag and set it.
// with cs.SetTexture
// RWTexture2D<float4> Result;

[numthreads(256, 1, 1)] void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= pairCount)
        return;
    int firstIndex = idx;
    float2 first = points[firstIndex].position;
    float2 firstOrigin = persistentPointInfo[firstIndex].initialPosition;
    float2 firstVelocity = points[firstIndex].velocity;
    Result initRes;
    initRes.firstVelocity = 0;
    results[firstIndex] = initRes;
    for (int i = 0; i < SPRING_COUNT; i++)
    {
        int springIndex = persistentPointInfo[firstIndex].springIndecies[i];
        if (springIndex == -1)
            break;
        int secondIndex = 0;
        if (firstIndex == springInfos[springIndex].firstIndex)
            secondIndex = springInfos[springIndex].secondIndex;
        else
            secondIndex = springInfos[springIndex].firstIndex;
        float2 second = points[secondIndex].position;
        float2 secondVelocity = points[secondIndex].velocity;
        float minDistance = springInfos[springIndex].initialDistance;
        float dist = distance(first, second);

        float2 secondFinalVelocity;
        float2 firstFinalVelocity;

        if (dist < minDistance) // abs(dist - minDistance) < 0.1)
        {
            firstFinalVelocity = float2(0, 0);
            secondFinalVelocity = float2(0, 0);
        }
        else
        {
            float force = (dist - minDistance) * springConstant;
            // if (dist < minDistance) force = -force;
            float2 direction = normalize(second - first);
            firstFinalVelocity = direction * force - firstVelocity * damping;
        }
        float firstOriginDistance = distance(first, firstOrigin);
        if (firstOriginDistance < maxReturnDistance && firstOriginDistance > 0.1)
        {
            float2 direction = normalize(firstOrigin - first);
            firstFinalVelocity += direction * returnForce * firstOriginDistance - firstVelocity * damping;
        }

        if (length(firstFinalVelocity) < minimumGate)
            firstFinalVelocity = firstFinalVelocity * (0.3 - 0.3 *(minimumGate - length(firstFinalVelocity)) / minimumGate) - firstVelocity * 0.5;

        results[firstIndex].firstVelocity += firstFinalVelocity * deltaTime;
    }
}